#pragma once

#include "config.h"

#include <cstdint>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "common/exception.h"
#include "common/io_limits_config_loader.h"

class IoLimitsDatabase {
public:
	typedef void* ClientId;
	typedef std::string GroupId;

	LIZARDFS_CREATE_EXCEPTION_CLASS_MSG(InvalidClientIdException, Exception,
			"invalid client id");

	LIZARDFS_CREATE_EXCEPTION_CLASS_MSG(ClientExistsException, Exception,
			"client already registered");

	LIZARDFS_CREATE_EXCEPTION_CLASS_MSG(InvalidGroupIdException, Exception,
			"invalid group id");

	// default constructor, all limits are zero
	IoLimitsDatabase() {}

	// set limits (as generated by IoLimitsConfigLoader)
	//
	// all limits in bytes per second
	//
	// changes take effect when clients try to alter their limits
	// (no support for master-initiated limit renegotiation)
	void setLimits(const IoLimitsConfigLoader::LimitsMap& limits);

	// get a list of all groups
	std::vector<std::string> getGroups() const;

	// add / remove a client
	void addClient(ClientId id);
	void removeClient(ClientId id);

	// try to satisfy client's request to change limit in given I/O group, return actual limit
	uint64_t setAllocation(const ClientId clientId, const GroupId& groupId, const uint64_t goal);

	// get client's limit in given I/O group
	uint64_t getAllocation(const ClientId clientId, const GroupId& groupId);

private:
	typedef uint64_t Allocation;
	typedef std::unordered_map<ClientId, Allocation> Allocations;

	struct GroupState {
		uint64_t limit;
		uint64_t allocated;
		Allocations allocations;
	};

	typedef std::unordered_set<ClientId> Clients;
	typedef std::map<GroupId, GroupState> Groups;

	GroupState& getGroup(const GroupId& id);
	Allocation& getAllocation(ClientId id, GroupState& group);

	Clients clients_;
	Groups groups_;
};
