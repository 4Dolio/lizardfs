#include "common/platform.h"
#include "mount/multi_variant_read_planner.h"

#include <algorithm>
#include <iterator>
#include <limits>

/*
 * The implementation is a bit dumb right now, but it should pass all the existing tests.
 * Proper generation of multi-variant plans has to be implemented.
 */

// Returns a part which should be avoided in the basic version of the plan,
// ie. the one with the lowest score. 'optimalParts' is a set of parts, which
// should not be chosen as worst part in case of equal scores.
static ChunkType getWorstPart(
		const std::map<ChunkType, float>& scores,
		const std::set<ChunkType>& optimalParts) {
	float worstScore = std::numeric_limits<float>::max();
	ChunkType worstPart = ChunkType::getXorParityChunkType(9);
	for (const auto& scoreAndPart : scores) {
		float score = scoreAndPart.second;
		ChunkType part = scoreAndPart.first;
		if (score < worstScore || (score == worstScore && optimalParts.count(worstPart) == 1)) {
			worstScore = score;
			worstPart = part;
		}
	}
	return worstPart;
}

void MultiVariantReadPlanner::prepare(const std::vector<ChunkType>& availableParts) {
	if (scores_.empty()) {
		for (const auto& part : availableParts) {
			scores_[part] = 1.0;
		}
	}
	// get list of parts which would be used if no scores were present
	standardPlanner_.prepare(availableParts);
	auto optimalParts = standardPlanner_.partsToUse();

	// choose a part with the worst score trying to avoid choosing one from 'optimalParts'
	ChunkType worstPart = getWorstPart(scores_, {optimalParts.begin(), optimalParts.end()});

	// filter out 'worstPart' from availableParts to get list of parts for the basic plan
	std::vector<ChunkType> bestParts;
	std::copy_if(availableParts.begin(), availableParts.end(), std::back_inserter(bestParts),
			[=](ChunkType type) { return type != worstPart; });
	standardPlanner_.prepare(bestParts);
	if (!standardPlanner_.isReadingPossible()) {
		standardPlanner_.prepare(availableParts);
	}
}

std::vector<ChunkType> MultiVariantReadPlanner::partsToUse() const {
	return standardPlanner_.partsToUse();
}

bool MultiVariantReadPlanner::isReadingPossible() const {
	return standardPlanner_.isReadingPossible();
}

std::unique_ptr<ReadPlanner::Plan> MultiVariantReadPlanner::buildPlanFor(
		uint32_t firstBlock, uint32_t blockCount) const {
	return standardPlanner_.buildPlanFor(firstBlock, blockCount);
}

void MultiVariantReadPlanner::setScores(std::map<ChunkType, float> scores) {
	scores_ = std::move(scores);
}

void MultiVariantReadPlanner::startAvoidingPart(ChunkType) {
	// TODO(msulikowski) to be implemented when both basic and additional read operations
	// are generated by this planer. As for now, we don't even have any spare parts available
	// in our standardPlanner_ to use them.
}
